c-----------------------------------------------------------------------
c
c Kovasznay flow, an analytical two-dimensional steady solution to the
c incompressible Navier-Stokes equations.  
c
c 
c This case tests user-explicit treatment of the nonlinear terms.
c 
c Specifically, it allows the user to set a rhs term of the form:
c 
c (1)    rhs = - [ (U.grad V) + (V.grad U) ]
c 
c where U and V can be vector fields of the user's choice.
c 
c Here, we test the functionality of this feature by considering the 
c Kovazsnay problem with the standard Nek5000 nonlinear treatment 
c turned OFF, which is accomplished by setting IFNAV to F in the .rea 
c file.   The net result is an unsteady Stokes problem.
c 
c We then augment the Stokes problem with a time-dependent forcing
c by setting ffx and ffy in userf() in the .usr file.  The pointwise
c values of ffx and ffy are taken from an array that is computed 
c once per timestep in userchk.   These nonlinear contributions
c are generated by the following ad hoc test routine:
c 
c       call set_ns_rhs   !  Test ad-hoc nonlinear function evaluation
c 
c which in turn makes the call to effect (1):
c 
c       call ugv_vgu(w1,w2,w3,vx,vy,vz,vx,vy,vz,1)
c 
c This case gives a final error of 1.e-8, a strong indicator that things
c are indeed functioning correctly.   Turning the functionality off via
c "call opzero(w1,w2,w3)" leads to and order unity error.
c 
c 
c    Note that the timing of the call to userhk is precisely correct
c in the following sense.  Userchk is called at the _end_ of the nth 
c timestep, when the time is set to  time=n*dt (for dt constant, say).
c 
c At this point, all arrays contain values associated with time t=n*dt.
c (On the first userchk call, just after setting initial conditions,
c we have time t=0.)
c 
c Thus, in the example described above the arrays w1() and w2() are
c filled with quantites from time-level n.
c 
c On the _next_ step, level n+1, the ffx and ffy arrays are filled by
c userf, which is expecting function values from time level n.   In fact,
c when userf() is called, the "time" variable is automatically set back
c to its value at Step n, in case the user is providing a function with
c an explicit dependence on time.   All values generated in userf() are
c then stored for the given time level, so that multiple preceding levels
c can be used to generate the proper kth-order extrapolation in time.
c 
c
c-----------------------------------------------------------------------
c
c  User specified routines 
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /c_my_ns/ w1(lx1,ly1,lz1,lelt)
     $                ,w2(lx1,ly1,lz1,lelt),w3(lx1,ly1,lz1,lelt)

      integer e,f,eg

      e = gllel(eg)

      ffx = 0
      ffy = 0
      ffz = 0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
c
      common /cprint/ ifprint
      logical         ifprint
      common /ctmp1e/ uxe (lx1,ly1,lz1,lelv), uye (lx1,ly1,lz1,lelv)
      common /scruz/  erru(lx1,ly1,lz1,lelv), errv(lx1,ly1,lz1,lelv)
     $               ,errw(lx1,ly1,lz1,lelv)
c
      integer icalld
      save    icalld
      data    icalld /0/

      real xp(ldim,10)

      ntot=nx1*ny1*nz1*nelv

      a1=1.0
      if (icalld.eq.0) then
         icalld=1
c
         vis=  param(2)
         if (vis.lt.0) vis = 1./abs(vis)
         one  =1.0
         twopi=8.0*atan(one)
         reyn=1.0/vis
         ccc = 0.25*reyn**2 + twopi*twopi
         rlam=reyn/2.0 - sqrt( ccc )
c
c        Compute the exact solution
c
         do 100 i=1,ntot
            x=xm1(i,1,1,1)
            y=ym1(i,1,1,1)
            uxe(i,1,1,1) =  1.0  - exp(rlam*x)*cos(twopi*y)
            uye(i,1,1,1) =  rlam * exp(rlam*x)*sin(twopi*y)/twopi
            errw(i,1,1,1) = 0.0
  100    continue
  101    format(3g14.7)
      endif
c     if (ifprint) then
c
c       Compute the error
c
        errmu=vx(1,1,1,1)-uxe(1,1,1,1)
        errmv=vy(1,1,1,1)-uye(1,1,1,1)
        do 200 i=1,ntot
           erru(i,1,1,1)=vx(i,1,1,1)-uxe(i,1,1,1)
           errv(i,1,1,1)=vy(i,1,1,1)-uye(i,1,1,1)
           if(erru(i,1,1,1).gt.errmu) then
              errmu=erru(i,1,1,1)
              iemu=i
           endif
           if(errv(i,1,1,1).gt.errmv) then
              errmv=errv(i,1,1,1)
              iemv=i
           endif
  200   continue
        errmu=glamax(erru,ntot)
        errmv=glamax(errv,ntot)
c
        ifield=1
        call normvc (h1,semi,hl2,hlinf,erru,errv,errw)
        call normvc (h1E,semiE,hl2E,hlinfE,uxe,uye,errw)
        hl2_wt = hl2/hl2e
c
        npoly = lx1-1
        if (nid.eq.0) write(6,301) istep,npoly,h1,semi,hl2,hlinf,time
  301   format(i6,i3,1p5e13.5,' err')
c     endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      vis    = param(2)
      one    = 1.0
      twopi  = 8.0*atan(one)
      reyn   = 1.0/vis
      ccc    = 0.25*reyn**2 + twopi*twopi
      rlam   = reyn/2.0 - sqrt( ccc )
      ux     = 1.0  - exp(rlam*x)*cos(twopi*y)
      uy     = rlam * exp(rlam*x)*sin(twopi*y)/twopi
      uz     = 0.0

      temp=0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      vis    = param(2)
      one    = 1.
      twopi  = 8.0*atan(one)
      reyn   = 1.0/vis
      ccc    = 0.25*reyn**2 + twopi*twopi
      rlam   = reyn/2.0 - sqrt( ccc )
      ux     = 1.0  - exp(rlam*x)*cos(twopi*y)
      uy     = rlam * exp(rlam*x)*sin(twopi*y)/twopi
      uz     = 0.0

      ux     = 0
      uy     = 0
      uz     = 0

      temp=0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'


      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
c-----------------------------------------------------------------------
